---
phase: 02-scanner
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - entrypoints/background.ts
  - entrypoints/content.ts
autonomous: false
requirements:
  - SCAN-01
  - SCAN-02
  - SCAN-04
  - SCAN-05
  - SCAN-07
  - SCAN-08

must_haves:
  truths:
    - "Clicking the extension icon on a page with Tags block invisible text reveals the decoded ASCII inline with yellow highlighting"
    - "Clicking the extension icon on a page with zero-width characters reveals [U+XXXX] labels inline with yellow highlighting"
    - "Extension badge shows the count of distinct findings after scan completes"
    - "Clicking the icon again clears all highlights, restores original DOM, and removes the badge"
    - "Scanning a clean page shows a green checkmark badge for 1.5 seconds then clears"
    - "MutationObserver catches dynamically added content and scans it while scan is active"
    - "Scanner skips script, style, noscript, template, and textarea elements"
    - "Injection on chrome:// or restricted pages fails gracefully without errors"
  artifacts:
    - path: "entrypoints/background.ts"
      provides: "Service worker with action.onClicked toggle, badge management, content script injection"
      contains: "chrome.action.onClicked"
    - path: "entrypoints/content.ts"
      provides: "Content script with DOM scanning, inline highlighting, MutationObserver, toggle clear"
      contains: "data-iu-highlight"
  key_links:
    - from: "entrypoints/background.ts"
      to: "utils/messaging.ts"
      via: "sendMessage import"
      pattern: "import.*sendMessage.*from.*messaging"
    - from: "entrypoints/content.ts"
      to: "utils/messaging.ts"
      via: "onMessage import"
      pattern: "import.*onMessage.*from.*messaging"
    - from: "entrypoints/content.ts"
      to: "utils/scanner.ts"
      via: "findInvisibleChars import"
      pattern: "import.*findInvisibleChars.*from.*scanner"
---

<objective>
Wire the background service worker and content script to perform on-demand page scanning with inline highlighting, badge count, and toggle off/on.

Purpose: This is the user-facing integration — clicking the extension icon triggers a full DOM scan, reveals hidden characters inline, shows a badge count, and clicking again restores the original page. This is the core value proposition of the extension.

Output: Working `entrypoints/background.ts` and `entrypoints/content.ts` that scan any web page on demand.
</objective>

<execution_context>
@C:/Users/jozwi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jozwi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scanner/02-RESEARCH.md
@.planning/phases/02-scanner/02-01-SUMMARY.md
@utils/scanner.ts
@utils/messaging.ts
@utils/charsets.ts
@utils/storage.ts
@wxt.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Background service worker with action.onClicked toggle and badge management</name>
  <files>entrypoints/background.ts</files>
  <action>
    Replace the stub background.ts with the full service worker implementation:

    1. Import sendMessage from utils/messaging.ts
    2. Listen on chrome.action.onClicked:
       a. Check tab.url — if starts with chrome://, about:, chrome-extension://, or matches chromewebstore.google.com, return early (no error, no action)
       b. Check badge text: `const badgeText = await chrome.action.getBadgeText({ tabId: tab.id })`
       c. If badgeText is NOT empty → scan is active → toggle OFF:
          - Try sendMessage('clearScan', undefined, tab.id) wrapped in try/catch
          - Clear badge: chrome.action.setBadgeText({ text: '', tabId: tab.id })
       d. If badgeText IS empty → no scan → toggle ON:
          - Try to ping content script: sendMessage('ping', undefined, tab.id)
          - If ping fails (catch block), inject content script: chrome.scripting.executeScript({ target: { tabId: tab.id }, files: ['/content-scripts/content.js'] })
          - After injection (or successful ping), send startScan: const result = await sendMessage('startScan', undefined, tab.id)
          - Update badge with result.count using updateBadge helper

    3. Implement updateBadge(tabId, count):
       - If count > 0: badge text = count > 999 ? '999+' : count.toString(), badge color = '#F44336' (red)
       - If count === 0: badge text = '\u2713' (checkmark), badge color = '#4CAF50' (green), setTimeout to clear badge after 1500ms

    4. Listen on chrome.tabs.onUpdated to clear badge when tab navigates:
       - If changeInfo.status === 'loading', clear badge text for that tab

    IMPORTANT: Do NOT define a default_popup in the manifest or add a popup entrypoint. chrome.action.onClicked does NOT fire when a popup is set.

    NOTE on content script path: WXT compiles content.ts to content-scripts/content.js in the build output. The files array in executeScript uses this path. If empirical testing shows a different path, adjust accordingly.
  </action>
  <verify>pnpm compile (TypeScript compiles without errors)</verify>
  <done>Background service worker handles icon click toggle, injects content script on first click, manages badge with count or checkmark, clears state on navigation, and gracefully ignores restricted URLs</done>
</task>

<task type="auto">
  <name>Task 2: Content script with DOM scanning, inline highlighting, MutationObserver, and toggle</name>
  <files>entrypoints/content.ts</files>
  <action>
    Replace the stub content.ts with the full content script implementation:

    1. Change to programmatic injection: use `registration: 'runtime'` in defineContentScript (no declarative injection on every page). Remove `matches: ['<all_urls>']` — the background injects on demand.

    IMPORTANT: Check WXT docs — registration: 'runtime' may require different syntax. If WXT does not support registration: 'runtime' directly, keep matches: ['<all_urls>'] but make the content script a no-op until it receives messages. The research notes indicate this is a valid alternative.

    2. Import onMessage from utils/messaging.ts
    3. Import findInvisibleChars, type ScanFinding from utils/scanner.ts
    4. Import highlightColorSetting from utils/storage.ts

    5. Module-level state:
       - let observer: MutationObserver | null = null
       - let scanActive = false
       - let totalFindings = 0

    6. Message handlers in main():
       a. onMessage('ping', () => 'pong')
       b. onMessage('startScan', async () => { return performFullScan(); })
       c. onMessage('clearScan', () => { clearAllHighlights(); stopObserving(); scanActive = false; totalFindings = 0; })

    7. performFullScan():
       a. Read highlight color: const color = await highlightColorSetting.getValue()
       b. scanActive = true; totalFindings = 0
       c. Walk DOM with createScanWalker(document.body):
          - Use document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, filterFn)
          - filterFn rejects text nodes inside SCRIPT, STYLE, NOSCRIPT, TEMPLATE, TEXTAREA, and nodes inside [data-iu-highlight] spans
       d. For each text node, call findInvisibleChars(textNode.textContent, 'standard')
       e. If findings exist, apply highlights using highlightFindings(textNode, findings, color)
       f. Count distinct findings (each ScanFinding = 1 finding for badge count)
       g. Start MutationObserver
       h. Return { count: totalFindings }

    8. highlightFindings(textNode, findings, color):
       Process findings in REVERSE order (highest offset first) to avoid invalidating earlier offsets when splitting:
       a. For each finding (reverse sorted by start):
          - Split text node at finding.start → get the match portion
          - Split match portion at (finding.end - finding.start) → isolate the match
          - Create span with: data-iu-highlight="true", data-iu-original=(finding.original), textContent=(finding.replacement)
          - Style span: backgroundColor=color, borderRadius='2px', padding='0 2px', fontFamily='monospace', fontSize='0.85em', color='#000'
          - Replace the match text node with the span

    9. clearAllHighlights():
       - document.querySelectorAll('[data-iu-highlight]') → for each span:
         - Create text node with span's data-iu-original value
         - Replace span with text node
         - textNode.parentNode?.normalize()

    10. MutationObserver (startObserving / stopObserving):
        - Observe document.body with { childList: true, subtree: true }
        - In callback, for each mutation.addedNodes:
          - Skip if node is or is inside a [data-iu-highlight] element (prevent infinite loop)
          - If element node: walk its subtree for text nodes and scan them
          - If text node: scan it directly
        - Use requestAnimationFrame to batch scan operations

    11. createScanWalker(root):
        - SKIP_TAGS = Set(['SCRIPT', 'STYLE', 'NOSCRIPT', 'TEMPLATE', 'TEXTAREA'])
        - Filter rejects text nodes whose parentElement is in SKIP_TAGS or has data-iu-highlight
  </action>
  <verify>pnpm compile (TypeScript compiles without errors); pnpm build (extension builds successfully)</verify>
  <done>Content script scans entire page DOM via TreeWalker, replaces invisible characters inline with highlighted decoded text or [U+XXXX] labels, watches for dynamic content via MutationObserver, and clears all highlights restoring original DOM on toggle</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify scanner end-to-end in Chrome</name>
  <action>Human verification of the built extension in a real Chrome browser.</action>
  <what-built>Complete on-demand page scanner: click extension icon to scan for invisible Unicode characters, see them revealed inline with yellow highlighting and badge count, click again to clear.</what-built>
  <how-to-verify>
    1. Run `pnpm build` in project root
    2. Open Chrome, go to chrome://extensions, enable Developer mode
    3. Click "Load unpacked" and select the `.output/chrome-mv3` directory
    4. Create a test HTML file with:
       - Tags block invisible text (use the encode function or paste pre-encoded text)
       - Zero-width characters (U+200B, U+200C, U+200D, U+FEFF)
       - Mix of visible and invisible text
    5. Open the test HTML file in Chrome
    6. Click the InvisibleUnicode extension icon
    7. Verify: invisible characters are revealed inline with yellow highlighting
    8. Verify: Tags block text shows decoded ASCII (e.g., "secret message")
    9. Verify: zero-width chars show labels like [U+200B]
    10. Verify: badge shows finding count (e.g., "3")
    11. Click the icon again
    12. Verify: all highlights disappear, page looks normal, badge clears
    13. Navigate to chrome://settings and click the icon
    14. Verify: nothing happens (no error in console)
    15. Open a clean page with no invisible characters
    16. Click the icon
    17. Verify: green checkmark badge appears briefly then clears
  </how-to-verify>
  <verify>Manual testing in Chrome browser with loaded extension</verify>
  <done>Extension scans pages for invisible Unicode, reveals them inline, shows badge count, toggles off cleanly</done>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
pnpm compile
pnpm lint
pnpm build
Manual test: load extension, scan a page with invisible Unicode, verify inline highlighting and badge
Manual test: toggle highlights off and back on
Manual test: verify restricted URL handling
</verification>

<success_criteria>
- Extension builds without errors
- Clicking icon on a page with Tags block text reveals decoded ASCII inline with yellow highlight
- Clicking icon on a page with zero-width chars reveals [U+XXXX] labels inline with yellow highlight
- Badge shows correct finding count after scan
- Clicking icon again clears all highlights and restores original DOM exactly
- Badge clears on toggle off
- Clean page shows green checkmark briefly
- MutationObserver catches dynamically added content
- Scanner skips script/style/noscript/template/textarea
- chrome:// pages handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-scanner/02-02-SUMMARY.md`
</output>
