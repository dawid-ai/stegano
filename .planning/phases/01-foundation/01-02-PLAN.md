---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - utils/codec.ts
  - tests/codec.test.ts
autonomous: true
requirements:
  - PLAT-01
  - PLAT-02

must_haves:
  truths:
    - "encode('Hello') produces Tags block invisible Unicode that is invisible in rendered text"
    - "decode(encode('Hello')) returns 'Hello' (round-trip)"
    - "encode('cafe\\u0301') throws a clear non-ASCII error"
    - "decode strips wrapper characters (U+E0001, U+E007F) when present"
    - "decode handles mixed visible + invisible input, preserving visible text"
    - "decode respects sensitivity level -- standard strips U+200B, thorough strips U+2060, paranoid strips U+202A"
    - "U+FEFF at position 0 is skipped during detection; U+FEFF elsewhere is detected"
    - "buildDetectionRegex returns a regex that matches all characters in the given sensitivity preset"
  artifacts:
    - path: "utils/codec.ts"
      provides: "encode() and decode() pure functions"
      exports: ["encode", "decode"]
      min_lines: 40
    - path: "tests/codec.test.ts"
      provides: "Comprehensive unit tests for encode/decode"
      min_lines: 80
  key_links:
    - from: "utils/codec.ts"
      to: "utils/charsets.ts"
      via: "imports PRESETS and SensitivityLevel"
      pattern: "import.*PRESETS.*charsets"
    - from: "tests/codec.test.ts"
      to: "utils/codec.ts"
      via: "imports encode and decode"
      pattern: "import.*encode.*decode.*codec"
---

<objective>
Implement encode/decode pure functions using TDD, with comprehensive unit tests covering all locked decision behaviors: ASCII-only encoding, sensitivity-aware decoding, wrapper handling, BOM handling, and round-trip correctness.

Purpose: The codec is the core logic of the entire extension. Every later phase (scanner, popup, snippets) depends on encode/decode working correctly. TDD ensures the contract is locked before implementation, catching non-BMP handling pitfalls early.

Output: Working, tested encode() and decode() functions with 100% coverage of the specified behaviors.
</objective>

<execution_context>
@C:/Users/jozwi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jozwi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<feature>
  <name>Unicode Encode/Decode Codec</name>
  <files>utils/codec.ts, tests/codec.test.ts</files>
  <behavior>
    encode(text, options?) -> invisible Unicode string
    - Maps each ASCII char to Tags block by adding 0xE0000 offset
    - ASCII only (0-127); throws Error with position info for non-ASCII
    - options.wrap=true wraps output in U+E0001 (begin) + U+E007F (cancel)
    - options.wrap defaults to false (raw output per locked decision)

    decode(input, sensitivity?) -> plaintext string
    - Tags block chars (U+E0020-E007E): reverse offset to ASCII
    - Wrapper chars (U+E0001, U+E007F): silently stripped (auto-detect wrapped vs raw)
    - Zero-width/invisible chars in active preset: silently stripped
    - Visible chars: passed through unchanged
    - sensitivity defaults to 'standard'
    - U+FEFF at position 0: skipped (BOM); U+FEFF elsewhere: stripped per preset

    Cases:
    - encode('Hi') -> two Tags block codepoints (U+E0048, U+E0069)
    - encode('Hi', {wrap:true}) -> U+E0001 + U+E0048 + U+E0069 + U+E007F
    - encode('') -> '' (empty string)
    - encode('cafe\u0301') -> throws Error
    - decode(encode('Hello')) -> 'Hello'
    - decode(encode('Test', {wrap:true})) -> 'Test'
    - decode('visible' + encode('hidden')) -> 'visiblehidden'
    - decode('a\u200Bb', 'standard') -> 'ab' (ZWSP stripped)
    - decode('a\u200Bb', 'thorough') -> 'ab' (ZWSP still stripped, thorough includes standard)
    - decode('a\u2060b', 'standard') -> 'a\u2060b' (word joiner NOT stripped in standard)
    - decode('a\u2060b', 'thorough') -> 'ab' (word joiner stripped in thorough)
    - decode('\uFEFF' + 'text', 'standard') -> 'text' (BOM at pos 0 skipped)
    - decode('te\uFEFFxt', 'standard') -> 'text' (FEFF mid-string stripped)
    - buildDetectionRegex('standard') matches U+200B but not U+2060
    - buildDetectionRegex('thorough') matches both U+200B and U+2060
  </behavior>
  <implementation>
    1. RED phase: Write tests/codec.test.ts with all the above test cases. Tests import encode, decode from utils/codec.ts. Run `pnpm test` -- all tests fail (module not found or assertion failures).

    2. GREEN phase: Implement utils/codec.ts:
       - Import PRESETS, SensitivityLevel from ./charsets
       - const TAGS_OFFSET = 0xE0000
       - encode(): validate ASCII with for...of + codePointAt, map with Array.from + String.fromCodePoint, optional wrap
       - decode(): iterate with for...of, handle Tags block (reverse offset for U+E0020-E007E), skip wrappers (U+E0001, U+E007F), check invisible ranges via preset, special BOM handling at position 0, pass through visible chars
       - Use codePointAt() not charCodeAt() for all non-BMP handling
       - Use for...of not indexed loops for correct codepoint iteration
       Run `pnpm test` -- all tests pass.

    3. REFACTOR phase (if needed): Clean up, ensure consistent error messages, add JSDoc comments to exported functions.

    IMPORTANT non-BMP handling:
    - MUST use String.fromCodePoint() not String.fromCharCode()
    - MUST use codePointAt() not charCodeAt()
    - MUST use for...of for iteration (handles surrogate pairs)
    - MUST use /gu flag on all regexes involving Tags block chars

    IMPORTANT BOM handling (per research recommendation, Claude's discretion):
    - Track character position during decode iteration
    - At position 0: skip U+FEFF silently (legitimate BOM)
    - At other positions: strip U+FEFF if in active preset ranges
  </implementation>
</feature>

<verification>
1. `pnpm test` passes all tests with 0 failures
2. Round-trip: decode(encode(text)) === text for various ASCII strings
3. Non-ASCII rejection: encode throws for any codepoint > 127
4. Wrapper handling: decode strips U+E0001/U+E007F when present, works without them
5. Sensitivity levels: standard ignores U+2060, thorough catches it, paranoid catches U+202A
6. BOM handling: U+FEFF at position 0 skipped, detected elsewhere
7. No network calls in codec.ts (ESLint lint passes)
</verification>

<success_criteria>
- All unit tests pass via `pnpm test`
- encode() correctly maps ASCII to Tags block codepoints
- encode() rejects non-ASCII input with informative error
- encode() supports optional wrapper characters
- decode() round-trips with encode() for all ASCII strings
- decode() auto-detects and strips wrapper characters
- decode() respects sensitivity level for zero-width character stripping
- decode() handles BOM correctly (skip at pos 0, detect elsewhere)
- buildDetectionRegex() produces correct regex for each sensitivity level
- No network-related code (lint passes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
