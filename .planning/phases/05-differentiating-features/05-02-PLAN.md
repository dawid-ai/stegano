---
phase: 05-differentiating-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/types.ts
  - utils/storage.ts
  - entrypoints/settings/index.html
  - entrypoints/settings/main.tsx
  - entrypoints/settings/App.tsx
  - entrypoints/settings/style.css
autonomous: true
requirements:
  - SNIP-01
  - SNIP-03

must_haves:
  truths:
    - "User can create a named snippet with invisible Unicode content on the settings page"
    - "User can see a list of all saved snippets on the settings page"
    - "User can edit a snippet's name, content, and shortcut on the settings page"
    - "User can delete a snippet from the settings page"
    - "Snippets persist in sync storage across browser sessions"
  artifacts:
    - path: "utils/types.ts"
      provides: "Snippet and SnippetShortcut interfaces"
      contains: "interface Snippet"
    - path: "utils/storage.ts"
      provides: "snippetsSetting storage item and CRUD helpers"
      contains: "snippetsSetting"
    - path: "entrypoints/settings/App.tsx"
      provides: "Snippet CRUD UI with list, create, edit, delete"
      min_lines: 50
    - path: "entrypoints/settings/index.html"
      provides: "Settings page HTML entrypoint"
      contains: "settings"
  key_links:
    - from: "entrypoints/settings/App.tsx"
      to: "utils/storage.ts"
      via: "reads and writes snippetsSetting"
      pattern: "snippetsSetting"
    - from: "utils/storage.ts"
      to: "utils/types.ts"
      via: "imports Snippet type"
      pattern: "import.*Snippet.*from.*types"
---

<objective>
Create the snippet data model, storage layer, and a settings page with full CRUD for managing named invisible Unicode snippets.

Purpose: Users need a way to save frequently-used invisible Unicode text as named snippets they can quickly access. The settings page provides the management interface; paste-via-shortcut comes in Plan 03.

Output: Snippet type definitions, sync storage with CRUD helpers, and a working settings page at chrome-extension://ID/settings.html.
</objective>

<execution_context>
@C:/Users/jozwi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jozwi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-differentiating-features/05-RESEARCH.md
@utils/types.ts
@utils/storage.ts
@entrypoints/popup/App.tsx
@entrypoints/popup/main.tsx
@entrypoints/popup/index.html
@entrypoints/popup/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Snippet type definitions and storage CRUD helpers</name>
  <files>utils/types.ts, utils/storage.ts</files>
  <action>
**utils/types.ts — Add Snippet and SnippetShortcut interfaces:**

```typescript
export interface SnippetShortcut {
  alt: boolean;
  shift: boolean;
  ctrl: boolean;
  /** Single key character (e.g., '1', 'a') */
  key: string;
}

export interface Snippet {
  /** Unique identifier (crypto.randomUUID) */
  id: string;
  /** User-assigned name */
  name: string;
  /** The invisible Unicode content (already encoded) */
  content: string;
  /** Optional keyboard shortcut for pasting */
  shortcut?: SnippetShortcut;
}
```

**utils/storage.ts — Add snippets storage and CRUD helpers:**

1. Import `Snippet` from types.ts.

2. Add `snippetsSetting`:
   ```typescript
   export const snippetsSetting = storage.defineItem<Snippet[]>(
     'sync:snippets',
     { fallback: [] },
   );
   ```
   Use sync storage (per prior decision: "sync storage for all settings"). The 8KB per-item limit allows ~15-18 snippets which is sufficient.

3. Add helper functions:
   ```typescript
   export async function addSnippet(snippet: Snippet): Promise<void> {
     const current = await snippetsSetting.getValue();
     await snippetsSetting.setValue([...current, snippet]);
   }

   export async function updateSnippet(id: string, updates: Partial<Omit<Snippet, 'id'>>): Promise<void> {
     const current = await snippetsSetting.getValue();
     await snippetsSetting.setValue(
       current.map(s => s.id === id ? { ...s, ...updates } : s)
     );
   }

   export async function deleteSnippet(id: string): Promise<void> {
     const current = await snippetsSetting.getValue();
     await snippetsSetting.setValue(current.filter(s => s.id !== id));
   }
   ```
  </action>
  <verify>Run `pnpm build` — builds without type errors.</verify>
  <done>Snippet and SnippetShortcut types exported from types.ts; snippetsSetting, addSnippet, updateSnippet, deleteSnippet exported from storage.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Settings page with snippet management UI</name>
  <files>entrypoints/settings/index.html, entrypoints/settings/main.tsx, entrypoints/settings/App.tsx, entrypoints/settings/style.css</files>
  <action>
Create a new WXT options page entrypoint at `entrypoints/settings/`. Follow the exact pattern from the existing popup entrypoint.

**entrypoints/settings/index.html:**
Standard HTML shell with `<div id="root"></div>` and `<script type="module" src="./main.tsx"></script>`. Title: "InvisibleUnicode Settings".

**entrypoints/settings/style.css:**
Single line: `@import "tailwindcss";` (same as popup/style.css).

**entrypoints/settings/main.tsx:**
Same pattern as popup/main.tsx — import Preact render, import App component, import style.css, render `<App />` into `#root`. Add `export default defineUnlistedScript(() => {});` — actually no, WXT options pages use a different pattern. For an unlisted page, the entry is just the HTML file. WXT auto-discovers `entrypoints/settings/index.html` as an extension page. The main.tsx just needs to mount Preact; no WXT defineX wrapper needed (same as popup/main.tsx which also has no wrapper).

**entrypoints/settings/App.tsx:**
Build a Preact component for snippet management with:

1. **State:** Load snippets from `snippetsSetting.getValue()` on mount. Watch for changes via `snippetsSetting.watch()`. Track `editingId: string | null` for inline editing.

2. **Snippet list:** Render each snippet as a card/row showing:
   - Name (bold)
   - Content preview (first 30 chars, shown as "[N invisible chars]" since content is invisible)
   - Shortcut display (e.g., "Alt+Shift+1") or "No shortcut"
   - Edit button, Delete button

3. **Create form:** A section at the top or bottom with:
   - Name input (text, required, placeholder "Snippet name")
   - Content textarea (text, required, placeholder "Paste invisible Unicode content here...")
   - Shortcut configurator: three checkboxes (Alt, Shift, Ctrl) + key input (single char). Alt+Shift should be pre-checked per prior decision about Alt+Shift prefix.
   - Save button. Generate `id` via `crypto.randomUUID()`.

4. **Edit mode:** When editingId is set, the corresponding snippet row transforms into an inline edit form (same fields as create). Save calls `updateSnippet()`. Cancel resets editingId to null.

5. **Delete:** Calls `deleteSnippet()` with confirmation (simple `confirm()` dialog is fine).

6. **Storage quota warning:** After each save, check if the serialized snippets array is approaching 8KB. Show a yellow warning banner if > 6KB. `JSON.stringify(snippets).length` gives a rough byte count.

7. **Styling:** Use Tailwind classes matching the popup's design language (gray-50 background, blue-600 primary buttons, sm text). Full-width page layout (not popup-sized). Max-width container centered.

8. **Link from popup:** In popup/App.tsx, this plan does NOT modify it. Plan 03 may add a link. For now the settings page is accessible via chrome-extension://ID/settings.html or right-clicking the extension icon.

**Important:** The settings page must be listed in the WXT config or placed so WXT auto-discovers it. WXT discovers HTML files in `entrypoints/` subdirectories automatically as extension pages. Verify by checking that `pnpm build` includes `settings.html` in the output.
  </action>
  <verify>Run `pnpm build` — settings.html appears in the build output. Open `chrome-extension://ID/settings.html` in a browser with the extension loaded — the page renders with the snippet management UI.</verify>
  <done>Settings page renders at settings.html with working snippet create, edit, delete, and list. Snippets persist in sync storage across page reloads.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with settings.html in output
- Snippet CRUD operations work via the settings page
- Snippets persist in sync storage
- No type errors
</verification>

<success_criteria>
- Snippet and SnippetShortcut types defined and exported
- snippetsSetting + addSnippet/updateSnippet/deleteSnippet available in storage.ts
- Settings page at settings.html with full snippet CRUD UI
- Storage quota warning displayed when approaching 8KB limit
</success_criteria>

<output>
After completion, create `.planning/phases/05-differentiating-features/05-02-SUMMARY.md`
</output>
