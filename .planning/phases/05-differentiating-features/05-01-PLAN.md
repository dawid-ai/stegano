---
phase: 05-differentiating-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/charsets.ts
  - utils/scanner.ts
  - entrypoints/content.ts
  - tests/scanner.test.ts
autonomous: true
requirements:
  - SCAN-03
  - SCAN-06

must_haves:
  truths:
    - "Scanner detects U+202F (Narrow No-Break Space) as a watermark-class finding"
    - "Scanner classifies findings into three distinct types: tags, zerowidth, watermark"
    - "Highlighted findings on the page use different colors per character class"
    - "Content script retains full findings array after scan for later retrieval"
  artifacts:
    - path: "utils/charsets.ts"
      provides: "AI_WATERMARK_CHARS map and WATERMARK_RANGES for detection regex"
      contains: "AI_WATERMARK_CHARS"
    - path: "utils/scanner.ts"
      provides: "Three-class classification (tags/zerowidth/watermark)"
      contains: "watermark"
    - path: "entrypoints/content.ts"
      provides: "Per-class highlight colors and findings storage"
      contains: "CLASS_COLORS"
    - path: "tests/scanner.test.ts"
      provides: "Tests for watermark classification"
      contains: "watermark"
  key_links:
    - from: "utils/scanner.ts"
      to: "utils/charsets.ts"
      via: "imports AI_WATERMARK_CHARS for classification"
      pattern: "AI_WATERMARK_CHARS\\.has"
    - from: "entrypoints/content.ts"
      to: "utils/scanner.ts"
      via: "reads finding.type for color selection"
      pattern: "finding\\.type"
---

<objective>
Add AI watermark character detection as a third character class in the scanner, with per-class highlight colors in the content script.

Purpose: Users need to distinguish AI-generated watermark characters (primarily U+202F) from Tags block encoded messages and generic zero-width invisible characters. This is the core differentiating feature of the extension.

Output: Extended scanner with three-class detection, per-class highlight colors, and findings retained in content script state.
</objective>

<execution_context>
@C:/Users/jozwi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/jozwi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-differentiating-features/05-RESEARCH.md
@utils/charsets.ts
@utils/scanner.ts
@entrypoints/content.ts
@tests/scanner.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add watermark character set and extend scanner classification</name>
  <files>utils/charsets.ts, utils/scanner.ts, tests/scanner.test.ts</files>
  <action>
**charsets.ts:**

1. Add a `AI_WATERMARK_CHARS` ReadonlyMap from codepoint to human-readable name. Per research recommendation, use a conservative set excluding U+00A0 (too many false positives from &nbsp;):
   ```
   0x202F -> 'Narrow No-Break Space'    (PRIMARY — GPT-o3/o4-mini/GPT-5)
   0x2003 -> 'Em Space'
   0x2002 -> 'En Space'
   0x2009 -> 'Thin Space'
   0x200A -> 'Hair Space'
   0x205F -> 'Medium Mathematical Space'
   ```
   Export it.

2. Add `WATERMARK_RANGES: CharRange[]` to include these characters in detection at the Standard sensitivity level. Add them to the `STANDARD_RANGES` array so they are always detected by `buildDetectionRegex()`. Use individual ranges or small contiguous ranges:
   - `{ start: 0x2002, end: 0x2003, name: 'En/Em Space (AI watermark)' }`
   - `{ start: 0x2009, end: 0x200a, name: 'Thin/Hair Space (AI watermark)' }`
   - `{ start: 0x202f, end: 0x202f, name: 'Narrow No-Break Space (AI watermark)' }`
   - `{ start: 0x205f, end: 0x205f, name: 'Medium Mathematical Space (AI watermark)' }`

**scanner.ts:**

1. Update `ScanFinding.type` union from `'tags' | 'zerowidth'` to `'tags' | 'zerowidth' | 'watermark'`.

2. Import `AI_WATERMARK_CHARS` from charsets.

3. Add a `classifyCodepoint(cp: number)` function implementing priority order: Tags block first, then watermark (via `AI_WATERMARK_CHARS.has(cp)`), then zerowidth fallback.

4. In `findInvisibleChars()`, replace the inline `isTagsBlock` check in the Phase 2 merge loop with the new classification. Non-tags matches should use `classifyCodepoint()` to set the type. For watermark findings, use the named label from `AI_WATERMARK_CHARS` instead of `[U+XXXX]` format: e.g., `[NNBSP]` for U+202F, or `[Narrow No-Break Space]`. Keep `[U+XXXX]` as fallback for zerowidth.

5. The Tags block merging logic remains unchanged — only Tags block characters are merged into runs. Watermark characters are individual findings like zerowidth characters.

**tests/scanner.test.ts:**

Add a new `describe('watermark detection')` block with tests:
- U+202F in text is classified as type 'watermark' with named label
- U+2003 (Em Space) is classified as type 'watermark'
- U+200B remains classified as 'zerowidth' (not watermark)
- Tags block characters remain classified as 'tags'
- Mixed text with all three classes returns correct types for each
- Watermark replacement text uses the named label from AI_WATERMARK_CHARS (not [U+XXXX])
  </action>
  <verify>Run `pnpm test` — all existing tests pass plus new watermark classification tests pass.</verify>
  <done>findInvisibleChars() returns 'watermark' type for AI_WATERMARK_CHARS codepoints with named labels, existing tags and zerowidth classification unchanged, all tests green.</done>
</task>

<task type="auto">
  <name>Task 2: Per-class highlight colors and findings retention in content script</name>
  <files>entrypoints/content.ts</files>
  <action>
1. Add a `CLASS_COLORS` constant mapping finding types to highlight colors:
   ```typescript
   const CLASS_COLORS: Record<string, string> = {
     tags: '#FFEB3B',      // Yellow — Tags block encoded messages
     zerowidth: '#FF9800', // Orange — Zero-width invisible chars
     watermark: '#E91E63', // Pink/Magenta — AI watermark indicators
   };
   ```

2. Update `highlightFindings()` to accept findings with type info and use `CLASS_COLORS[finding.type]` for the background color instead of the single `color` parameter. If the user's custom `highlightColorSetting` is set to something other than the default '#ffeb3b', use the custom color for ALL classes (backward compatibility). Otherwise use per-class colors.

   Implementation: In `performFullScan()`, read `highlightColorSetting`. If it equals the default '#ffeb3b', pass `null` as color to `highlightFindings` (signals per-class mode). If custom, pass the custom color. In `highlightFindings`, if color is null, use `CLASS_COLORS[finding.type]`; otherwise use the provided color.

3. Add a module-level `let allFindings: ScanFinding[] = []` array. In `performFullScan()`, reset it to `[]` at the start, and after each `scanTextNode()` call, push the findings to `allFindings`. This requires modifying `scanTextNode()` to return the findings array (not just the count).

4. In the `clearScan` handler, also reset `allFindings = []`.

5. The `highlightColorSetting.watch()` handler should also update per-class or custom colors on existing highlights. If custom color, apply to all. If default, apply per-class by reading `data-iu-type` attribute (add this attribute to highlight spans in `highlightFindings()`).

6. In `highlightFindings()`, add `data-iu-type` attribute to each span set to `finding.type`. This enables the reactive color watch to reapply per-class colors.

7. In the MutationObserver's `scanTextNode` calls, also push findings to `allFindings`.
  </action>
  <verify>Run `pnpm build` — builds without errors. Manually verify in dev mode that scan highlights use different colors for different character classes.</verify>
  <done>Content script applies yellow/orange/pink highlights based on finding type, stores all findings in module state, and the reactive color watch handles per-class coloring.</done>
</task>

</tasks>

<verification>
- `pnpm test` passes all existing + new watermark tests
- `pnpm build` succeeds
- Scanner correctly classifies U+202F as 'watermark' type
- Content script stores findings array for later retrieval (Plan 03 will add the messaging)
</verification>

<success_criteria>
- findInvisibleChars() detects 6 AI watermark characters and classifies them as type 'watermark'
- Watermark findings use named labels (e.g., "[Narrow No-Break Space]") not hex codes
- Tags block and zero-width classification unchanged (backward compatible)
- Content script highlights use per-class colors: yellow for tags, orange for zerowidth, pink for watermark
- All findings stored in allFindings array for export feature (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/05-differentiating-features/05-01-SUMMARY.md`
</output>
